# 搜索

> 需要前置芝士数据结构-队列

## 目录


### bfs 广度优先搜索

#### 前置芝士 - 数据结构 - 队列



#### bfs概念

[概念](#概念)

#### 例题

[例题](#例题)

#### bfs模板

[模板](#模板)

#### 相关习题

[习题](#习题)


## BFS

 <a name="概念">概念</a>

 广度优先搜索（也称宽度优先搜索，缩写BFS）是[连通图](#连通图)的一种遍历策略。因为它的思想是从一个顶点开始，辐射状地优先遍历其周围较广的区域，因此得名。

 上面的定义比较抽象，我们通过一个实际的问题引入bfs：

 <a name="例题">例题</a>

 在一个3*3的矩阵中：假设我们不考虑终点，只考虑一个起点：

 > 我们定义图中左上角(1,1)点为原点

 > 同时定义每次只能走上下左右的一个格子

 如何通过bfs的方法得到每个点的最短路呢？

```python
 m\n 1 2 3    #你说什么？这不是代码，这是压缩毛巾，遇水变大变高
 1 [[0,0,0]
 2  [0,0,0]
 3  [0,0,0]]
```

如图：我们容易想到距离原点步长为1的点为(2,1),(1,2)

距离原点步长为2的点为(2,2),(3,1),(1,3)

以此类推： 我们可以通过得到的数据画出以下的树结构：

0.           (1,1)
            /     \
1.        (2,1)    (1,2)   
           /  \        \
2.      (3,1)  (2,2)   (1,3)  
         /       \
3.    (3,2)    (2,3)   
        /
4.   (3,3)

这种一层层向下遍历的方式就是广度优先遍历，

本例中遍历顺序为层数从小到大，每层从左向右遍历。



 <a name="模板">模板</a>

在上图中，我们发现每层的数据都是由上一层的点所推出。

因此如果我们想要实现这种逐层遍历的算法就需要找到两者之间的关系。

我们知道每次只能走上下左右的一个格子，那么当我们从所在地开始移动就有上下左右4种情况：

因此我们可以引入一个表示期望移动的数组：[(1,0),(0,1),(-1,0),(0,-1)]

对于每个点，只要通过一层循环遍历该数组就可以得到下一步可能移动到的位置。

这时，我们又遇到了一个新的问题；如果下一步可能移动到的位置超出了原二维列表索引怎么办？

为了解决这个问题，我们需要编写一个判断移动后的点是否超出索引范围的函数：

```python
#python版
def check(xy, n, m):#xy是一个(x,y)形式的元组，表示一个坐标，
    '''该函数判断点(x,y)是否合法，即是否在长n，宽m的范围内'''
    if 0 <= xy[0] < n and 0 <= xy[1] < m:
        return True
    return False
```

```cpp
//cpp版
bool check(int xy[], int n, int  m)://xy是一个(x,y)形式的元组，表示一个坐标，
    //该函数判断点(x,y)是否合法，即是否在长n，宽m的范围内
    if (0 <= xy[0] && xy[0] < n && 0 <= xy[1] && xy[1] < m)return true;
    else return false;
```

接下来考虑其他需要判断的条件：

如何保证每个点只被遍历一次？ 因为我们需要按照每层都距离原点步数相等的条件进行遍历，这样每个点到原点的距离都是可行最短路。

为了保证每个点被第一次遍历时就被记录，同时作为条件供后续遍历的判断条件(如果已经被记录就不要再重复遍历)

我们可以引入一个与原矩阵大小相同的布尔类型矩阵，其他形式同理，用于判断该点是否被记录过。

对于本题而言，我们可以简化，直接用所需答案的整数类型数组代替布尔数组，一样能够实现判断该点是否被记录过

```python
ans = [[-1 for _ in range(m)] for _ in range(n)]#将所有点初始化为-1
ans[x][y]=0#原点距原点距离是0
```
经过记录，我们已经解决了判断的问题;


<a name="模板">模板</a>

接下来给出bfs最普遍的模板：

```python
q.push(初始状态)#初始化队列q，填入初始坐标
while not q.empty():#如果队列q不为空继续循环
    u=q.get()#出队首
    for i in (枚举期望状态):
        if check(判断是否合法):
            q.put(i)#将新状态入队;
    
```

```cpp
q.push(初始状态);//初始化队列q，填入初始坐标
while (!q.empty()){//如果队列q不为空继续循环
    State u=q.front;//出队首
    for (枚举期望状态):
        if check(判断是否合法):
            q.push(i)//将新状态入队;
}
    
```

这就是bfs的通用模板，但是对于具体问题需要具体分析，

不难发现，虽然模板的枚举顺序大体是按照一层一层的顺序遍历，但是无法明确判断属于第几层，

因此我们需要一个变量记录当前是第几层和额外添加一个循环在'''while not q.empty()'''里用于遍历该层

直接给出完整解决该问题的代码:

```python
from queue import Queue#直接使用内置队列数据结构，其实直接通过列表实现也可以

def pand(w, i):#移动函数，返回移动后的x,y元组
    a = w[0] + i[0]
    b = w[1] + i[1]
    return (a, b)

def check(xy, n, m):
    if 0 <= xy[0] < n and 0 <= xy[1] < m:
        return True
    return False

def bfs(ans, q, n, m, pan,x,y):#可对比模板，看看哪里不同
    op = 0
    while not q.empty():
        op += 1
        size = q.qsize()  # 获取当前层的节点数
        for _ in range(size):#循环所有节点，即将该层节点都循环一遍
            w = q.get()#出队头
            for i in pan:
                r = pand(w, i)
                if check(r, n, m) and ans[r[0]][r[1]] == -1 :
                    q.put(r)
                    ans[r[0]][r[1]] = op

if __name__ == '__main__':
    q = Queue()#初始化队列
    n, m, x, y = map(int, input().split())#输入 长，宽，起始点x,y
    x, y = x - 1, y - 1
    q.put((x, y))
    ans = [[-1 for _ in range(m)] for _ in range(n)]#答案全部初始化为-1
    ans[x][y]=0
    pan = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    bfs(ans, q, n, m, pan,x,y)
    for i in ans:
        print(" ".join(map(str, i)))
    
```

```cpp
//明天写
    
```


 <a name="习题">习题</a>

 [洛谷p1443🐎的遍历][def]

[def]: https://www.luogu.com.cn/problem/P1443 "🐎的遍历"

[洛谷p1162填涂颜色](https://www.luogu.com.cn/problem/P1162 "填涂颜色")


注：

 <a name="连通图">连通图</a>

 连通图（一般都是指无向图）：
 从顶点v到w有路径，就称顶点v和m连通。（路径是由顶点和相邻顶点序偶构成的边所形成的序列，其实就是一堆相连的顶点及其边）

 详见图论