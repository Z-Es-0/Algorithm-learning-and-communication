[石子合并](https://www.luogu.com.cn/problem/P1775)


## dp数组含义


区间dp，顾名思义，dp数组的含义是区间合并的最优解。

dp[i][j]表示区间i(begin) 到 j(end) 的合并成一个区间时的最优解。

对于dp数组含义为区间的dp有很多。这道题只是比较逆天的3维dp

## 状态转移方程

考虑基础情况，区间只有一个值的时候，合并成本为0

区间只有两个值的时候，成本为sum(s[i],s[i+1])

考虑递推情况；

3个值形成一个区间： 假设这3个值为 {a,b,c}

考虑这个区间的合并情况：  

a ,[b,c]  或 [a,b],c

对于3个值一个区间： 有以上两种情况， 观察情况，发现任何>=2的区间都是由两个区间合并而成，那么可以发现这用dp做再合适不过了；

因为对于最后一次合并的成本一定是这段区间和，那么我们在状态转移的时候只要加上区间和就可以避免考虑重复贡献问题；

区间和完全可以用前缀和维护，可以优化时间。

对于一个区间答案的求解，我们考虑枚举这两个区间的分割点；

对于一个分割点，我们写出以下的状态转移方程：

> 设k为枚举出的分割点，定义从i到k是左区间，k+1到j是右区间，那么整个区间的合并成本就是以下方程

可行的dp[i][j] = dp[i][k]+dp[k+1][j]+Σ(x=i,x<= j,x++)s[x];

考虑枚举k的所有情况，那么我们只需要在这个状态转移方程外面套一层循环枚举k；同时维护一个最小值，在最后更新dp[i][j]的时候使用我们维护的最小值即可；

## 遍历顺序

观察我们的状态转移方程：

发现，我们想要推出dp[i][j]需要的值在dp数组上是以它为直角顶点的一个等腰三角形，因为我们需要知道所有和它有递推关系的dp[][]；

所以我们需要子集设计dp的遍历顺序，注意到，斜着进行状态转移是一种完善的遍历顺序；

考虑代码实现这种奇怪的遍历顺序，注意到，在同一斜线上有：j-i为定值，而且随着层数的增加j-i也在增加；

可以写出以下代码：

```cpp

    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < n-i; ++j) {
            a=j;b=j+i;
            cout << "a and b is" << ' ' << a << ' ' << b << endl;
            }
        }

```

打印出a,b；发现是正确的斜线遍历；

然后将前面推出的状态转移方程带入即可


## code


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int ans,n;
int s[305],qz[305];
int dp[305][305];
int a,b,r;
void solve(){
    cin>>n;
    for (int i = 0; i < n; ++i) {
        cin>>s[i];

        r+=s[i];
        qz[i+1]=r;
    }
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < n-i; ++j) {
            a=j;b=j+i;
//            cout << "a and b is" << ' ' << a << ' ' << b << endl;

             {
                int mn = LLONG_MAX;
                for (int k = a ; k < b; ++k) {
                    int p;
                    p=dp[a][k]+dp[k+1][b]+qz[b+1]-qz[a];
                    mn=min(mn,p);
//                    cout<<p<<' '<<a <<' '<<k <<endl;
                }
                dp[a][b]=mn;
            }

        }
    }
//    for (int i = 0; i < n; ++i) {
//        for (int j = 0; j < n; ++j) {
//            cout<<dp[i][j]<<' ';
//        }
//        cout<<endl;
//    }
    cout<<dp[0][n-1]<<endl;
}
signed main(){

    solve();
    return 0;
}
```