<!--
 * @Author: Z-Es-0 zes18642300628@qq.com
 * @Date: 2024-06-03 12:58:18
 * @LastEditors: Z-Es-0 zes18642300628@qq.com
 * @LastEditTime: 2024-10-03 04:47:40
 * @FilePath: \Algorithm-learning-and-communication\算法\小寄巧\自研萧寄巧.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
## 单点查询区间覆盖标记 (构造O(n) , 查询O(sqrt(x))) / 二进制状压复杂度更低

问题：

给定一个区间数组，要求查询数轴上某个点被哪几个区间涵盖；

solve:

已知：任意实数x=几个素数积的形式；而且素数集唯一；

那么对于每个区间可以分配一个素数作为标记；

2->区间1，3->区间2.。。。。

这样只要构造一个除分数组再做前缀积就能得到一个数组；

对这个数组上某个点进行素数因子的拆分，我们发现，拆分出的素数即为覆盖该点的区间编号；

复杂度是素因子拆分的复杂度， sqrt(n) 或者优化后的复杂度，

但是对于x，我们不能太大，所以本算法局限性很大；


> 只要是符合群结构的都能进行前缀操作


## 区间查询区间覆盖数量 

[强行歪解](https://codeforces.com/contest/2014/problem/D)

> 针对本题来说，正解太简单了，上点普适性强的算法；

我们先维护出区间的差分链表数组；(我们把每次操作都记录在链表中，即每次+1,-1都记录下来而不是计算)

然后固定一个差为k的双指针，l,r; r-l=k;

然后遍历，对于r遇见的差分[i]的链表，我们遍历链表，遇见+1 就对sum++;

对于l遇见的差分[i]链表，遍历链表，遇见-1,就对sum--;

这样我们就在O(n+m)复杂度内解决了， n:数组长度，m:区间数；


```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long
#define lowbit(x) (x & (-x))
#define N 200005
#define MOD (1e9+7)
int t,n,l,r,k,d;

void solve(){
    cin>> n>>d>>k;
    vector<vector<int>> cf(n+2);
    for (int i = 0; i < n+1; ++i) {
        cf[i].clear();
    }
    for (int i = 0; i < k; i++)
    {
        cin>>l>>r;
        cf[l].push_back(1);
        cf[r+1].push_back(-1);
    }
    int sum =0;
//    for (int i = 1; i <=n ; ++i) {
//        cout<<i<<" wise this ";
//        for (int j : cf[i]) {
//            cout<<j<<' ';
//        }
//        cout<<endl;
//    }
    for (int i = 1; i <= d ; ++i) {
        for (int j : cf[i]) {
            if (j>0){
                sum++;
            }
//        cout<<j<<' ';

        }
//        cout<<endl;
    }
    int cmax=sum,cmin=sum,ans1=1,ans2=1;
    for (int i = 2; i <= n-d+1; ++i) {

        for (int j : cf[i]) {
            if (j<0){
                sum--;
            }
        }
        for (int j : cf[i+d-1]) {
            if (j>0){
                sum++;
            }
        }
        if (sum>cmax){
            cmax=sum;
            ans1=i;
        }
        if (sum<cmin){
            cmin = sum;
            ans2 = i;
        }
    }
    cout<<ans1<<' '<<ans2<<endl;
}
signed main(){
ios::sync_with_stdio(false);
cin.tie(nullptr);
cin>>t;
while(t--){
    solve();
 }
return 0;
}
```











