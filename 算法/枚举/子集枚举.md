# 枚举

> 以下介绍的‘集合’概念不是python的数据结构set，是数学上的集合概念。


## 目录


### 子集枚举

#### 位运算

[位运算](#位运算)

#### 集合的引入

[集合原理](#集合原理)

#### 集合的常用关系


[并集](#并集)

[交集](#交集)

[包含](#包含)




## 子集枚举



 <a name="位运算">位运算</a>

位运算通常比正常的数学运算要快，它们在硬件层面上执行，并且可以更高效地操作二进制表示的数据。位运算在计算机科学和工程中广泛使用，因为它们可以加速许多操作。

位运算的时间复杂度通常是 O(1)，它们在一个步骤内完成。这意味着无论输入数据的大小如何，位运算所花费的时间都是常数级别的。

位运算的空间复杂度也通常是 O(1)，它们不需要额外的存储空间来执行操作。它们只是在寄存器或内存中直接操作位。

所以位运算在一些场景中是一种必要的优化方式，子集枚举正是利用了位运算与二进制的独特表示形式产生的算法。

i1  i2  按位与  按位或   异或    取反

| A | B | A&B | A|B | A^B | ~A |

| 0 | 0 |   0   |  0  |   0   |  1 |

| 0 | 1 |   0   |  1  |   1   |  1 |

| 1 | 0 |   0   |  1  |   1   |  0 |

| 1 | 1 |   1   |  1  |   0   |  0 |

还有一些位运算比如'被操作数字<<移动的位数'即二进制数向左移;比如1<<2:

1<<2=4:  1==(0001)b;  (0100)b==4;

```python
print(1<<2)
```

反之 ‘>>’即二进制向右移动



 <a name="集合原理">集合原理</a>

 思考集合{1，2，3，4}在这个集合中，我们可以一眼看出它的子集：

 {}空集，{1}，{2}，{3}，{4}，{1，2}，{1，3}，{1，4}，{2，3}，{2，4}，{3，4}，{1，2，3}，{2，3，4}，{1，3，4}，{1，2，4}，{1，2，3，4}全集。

 通过数出这些子集的数量，得到一共有16个集合。

 继续这样的操作，我们不难找到规律：集合的子集数量与全集的元素数量有关。
 
 以下给出证明：

全集：{1，2，3，4}，，长度为4，我们假设他的顺序固定。

我们将它的每个子集用一个长度为4的只含0和1的字符串表示，

其中0 代表该子集不包含该元素，1代表该子集包含该元素。

 {}  ---> 0000 

 {1} ---> 0001

 {2} ---> 0010

 {3} ---> 0100

 {4} ---> 1000

 {1,2} ---> 0011

 以此类推;

可以看到，每个子集都有一个唯一的对应的n位二进制字符串。而n位二进制字符串有2^n种可能性（每个位置可以是0或1），所以有2^n个不同的子集。

因此，全集可以通过位运算得到，

```python
setn=(1<<n)-1#1<<n所表示的二进制数字是1后面n个0，(1<<n)-1得到的是n个1，即所有元素都被选中。表达全集

set0=0#0的二进制就是000000表示空集

seti=(1<<(i-1))#向左移动i-1位得到仅包含第i个元素的子集
```

```cpp
int setn=(1<<n)-1//int类型存数字就行
```


 <a name="并集">并集</a>

