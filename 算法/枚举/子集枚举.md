# 枚举

> 以下介绍的‘集合’概念不是python的数据结构set，是数学上的集合概念。


## 目录


### 子集枚举

#### 位运算

[位运算](#位运算)

#### 集合的引入

[集合原理](#集合原理)

#### 集合的常用关系


[并集](#并集)

[交集](#交集)

[包含](#包含)

#### 相关习题

[习题](#习题)


## 子集枚举



 <a name="位运算">位运算</a>

位运算通常比正常的数学运算要快，它们在硬件层面上执行，并且可以更高效地操作二进制表示的数据。位运算在计算机科学和工程中广泛使用，因为它们可以加速许多操作。

位运算的时间复杂度通常是 O(1)，它们在一个步骤内完成。这意味着无论输入数据的大小如何，位运算所花费的时间都是常数级别的。

位运算的空间复杂度也通常是 O(1)，它们不需要额外的存储空间来执行操作。它们只是在寄存器或内存中直接操作位。

所以位运算在一些场景中是一种必要的优化方式，子集枚举正是利用了位运算与二进制的独特表示形式产生的算法。

i1  i2  按位与  按位或   异或    取反

| A | B | A&B | A|B | A^B | ~A |

| 0 | 0 |   0   |  0  |   0   |  1 |

| 0 | 1 |   0   |  1  |   1   |  1 |

| 1 | 0 |   0   |  1  |   1   |  0 |

| 1 | 1 |   1   |  1  |   0   |  0 |

还有一些位运算比如'被操作数字<<移动的位数'即二进制数向左移;比如1<<2:

1<<2=4:  1==(0001)b;  (0100)b==4;

```python
print(1<<2)
```

反之 ‘>>’即二进制向右移动



 <a name="集合原理">集合原理</a>

 思考集合{1，2，3，4}在这个集合中，我们可以一眼看出它的子集：

 {}空集，{1}，{2}，{3}，{4}，{1，2}，{1，3}，{1，4}，{2，3}，{2，4}，{3，4}，{1，2，3}，{2，3，4}，{1，3，4}，{1，2，4}，{1，2，3，4}全集。

 通过数出这些子集的数量，得到一共有16个集合。

 继续这样的操作，我们不难找到规律：集合的子集数量与全集的元素数量有关。
 
 以下给出证明：

全集：{1，2，3，4}，，长度为4，我们假设他的顺序固定。

我们将它的每个子集用一个长度为4的只含0和1的字符串表示，

其中0 代表该子集不包含该元素，1代表该子集包含该元素。

 {}  ---> 0000 

 {1} ---> 0001

 {2} ---> 0010

 {3} ---> 0100

 {4} ---> 1000

 {1,2} ---> 0011

 以此类推;

可以看到，每个子集都有一个唯一的对应的n位二进制字符串。而n位二进制字符串有2^n种可能性（每个位置可以是0或1），所以有2^n个不同的子集。

因此，全集可以通过位运算得到，

```python
setn=(1<<n)-1#1<<n所表示的二进制数字是1后面n个0，(1<<n)-1得到的是n个1，即所有元素都被选中。表达全集

set0=0#0的二进制就是000000表示空集

seti=(1<<(i-1))#向左移动i-1位得到仅包含第i个元素的子集
```

cpp版

```cpp
int setn=(1<<n)-1//int类型存数字就行
```



 <a name="并集">并集</a>

在集合中，两个集合的并集是包含这两个集合中所有不重复元素的集合。在位运算中，可以通过按位或（|）来实现两个集合的并集。

```python
set1 = 0b1010  # 代表集合 {1, 3}
set2 = 0b0011  # 代表集合 {2, 4}

union_set = set1 | set2
print(bin(union_set)[2:].zfill(4))  # 输出 1011，表示并集 {1, 2, 3, 4}
```

上述代码中，set1 | set2表示对两个集合进行按位或操作，得到并集。通过将结果转换为二进制表示，我们可以看到并集包含了两个集合的所有元素。

```python
s1={1,3}
s2={2,4}
print(s1|s2) # 输出并集 {1, 2, 3, 4}
```

与python中集合操作相同


 <a name="交集">交集</a>

接下来是集合的交集。在集合中，两个集合的交集是包含这两个集合中共同元素的集合。在位运算中，可以通过按位与（&）来实现两个集合的交集。

```python
set1 = 0b1010  # 代表集合 {1, 3}
set2 = 0b0011  # 代表集合 {2, 4}

intersection_set = set1 & set2
print(bin(intersection_set)[2:].zfill(4))  # 输出 0010，表示交集 {2}
```

上述代码中，set1 & set2表示对两个集合进行按位与操作，得到交集。通过将结果转换为二进制表示，我们可以看到交集包含了两个集合的共同元素。

python中set同样操作

 <a name="包含">包含</a>

 最后是集合的包含关系。在集合中，一个集合是否是另一个集合的子集或超集，可以通过位运算来判断。具体来说，如果一个集合A是另一个集合B的子集，那么A与B的按位与结果应该等于A；如果A是B的超集，那么A与B的按位与结果应该等于B。

```python
setA = 0b1010  # 代表集合 {1, 3}
setB = 0b1011  # 代表集合 {1, 2, 3, 4}

is_subset = setA & setB == setA
is_superset = setA & setB == setB

print(is_subset)    # 输出 True，表示setA是setB的子集
print(is_superset)  # 输出 False，表示setA不是setB的超集
```

上述代码中，setA & setB == setA表示判断setA是否是setB的子集，而setA & setB == setB表示判断setA是否是setB的超集。


>c++版本(代码片段)


```cpp
int set1 = 0b1010;  // 代表集合 {1, 3}
int set2 = 0b0011;  // 代表集合 {2, 4}

// 并集
int unionSet = set1 | set2;
// 输出结果：1011

// 交集
int intersectionSet = set1 & set2;
// 输出结果：0010

// 包含关系的判断
bool isSubset = (set1 & set2) == set1;  // set1 是否是 set2 的子集
bool isSuperset = (set1 & set2) == set2;

```





<a name="习题">习题</a>

[洛谷p1036](https://www.luogu.com.cn/problem/P1036 "P1036 [NOIP2002 普及组] 选数")

[洛谷p2036](https://www.luogu.com.cn/problem/P2036 "P2036 [COCI 2008/2009 #2] PERKET")

[POJ 1543 完美立方](http://poj.org/problem?id=1543 "Perfect Cubes")

[POJ 1006](http://poj.org/problem?id=1006 "Biorhythms")

[POJ](http://poj.org/ "Orz")