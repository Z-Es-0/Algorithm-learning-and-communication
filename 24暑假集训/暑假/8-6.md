
[dp/math](https://codeforces.com/contest/2/problem/B)

## 简单数学，逆天细节

观察这个问题；

## math

发现： 对于0的个数，与2和5的个数相关，对于一个数的因子中关于min(count(2),count(5)) = 0的个数 

那么我们只需要预处理 出 每个数的 因子2的个数 和 因子5的个数 ；为数组v2,v5；

## dp

那么考虑经典的dp问题； 从左上到右下的路径中2/5个数的最小值 ；因为对于ans = min(count(2),count(5)) ； 所以我们只需要找到最小的count(2)和count(5)即可；那么我们完全可以分别状态转移寻找count(2) and count(5)；

## 状态表示

pair<int ,int >dp[N][N];

dp[i][j].first 表示到 矩阵[i][j]的位置时最少2的因子个数

dp[i][j].seced 表示到 矩阵[i][j]的位置时最少5的因子个数

## 状态转移

> dp[i][j].first = min(dp[i-1][j].first , dp[i][j-1].first)+v2[i][j]

> dp[i][j].secend = min(dp[i-1][j].secend , dp[i][j-1].secend)+v2[i][j]

## 路径输出

递归写，只需要编辑在dp[n-1][n-1] 位置2，5数量比较小的那个的路径就可以 ； 

## code

乱七八糟的代码

```cpp

// LUOGU_RID: 170801933
#include <bits/stdc++.h>

using namespace std;
#define int long long
#define lowbit(x) x&(-x)
#define N 1003
#define EXM 1000000003
int s[N][N];
int n, t;
pair<int ,int >dp[N][N];
char lst[N][N];
stack<char>ans;
int v2[N][N];
int v5[N][N];
int op2(int k){
    int l=0;
    while (k%2 == 0){
        k/=2;
        l++;
    }
    return l;
}

int op5(int k){
    int l=0;
    while (k%5 == 0){
        k/=5;
        l++;
    }
    return l;
}
void dfs1(int x,int y){
    if (x==0 && y==0){
        return;
    }
    else if (x==0){
        ans.push('R');
        dfs1(x,y-1);
    }
    else if (y ==0){
        ans.push('D');
        dfs1(x-1,y);
    }
    else{
        if (dp[x][y].first == dp[x-1][y].first + v2[x][y]){
            ans.push('D');
            dfs1(x-1,y);
        }
        else {
            ans.push('R');
            dfs1(x,y-1);
        }
    }
}
void dfs2(int x,int y){
    if (x==0 && y==0){
        return;
    }
    else if (x==0){
        ans.push('R');
        dfs2(x,y-1);
    }
    else if (y ==0){
        ans.push('D');
        dfs2(x-1,y);
    }
    else{
        if (dp[x][y].second == dp[x-1][y].second + v5[x][y]){
            ans.push('D');
            dfs2(x-1,y);
        }
        else {
            ans.push('R');
            dfs2(x,y-1);
        }
    }
}


void solve() {
    cin>>n;
    bool ned_check = false;
    pair<int ,int >ned;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            cin>> s[i][j];
            if (s[i][j] ==0 ){
                ned_check=true;
                ned.first=i;
                ned.second=j;
            }
        }
    }
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (s[i][j] ==0)continue;
            v2[i][j]= op2(s[i][j]);
            v5[i][j] = op5(s[i][j]);
        }
    }
    dp[0][0].first=v2[0][0];
    dp[0][0].second=v5[0][0];
    for (int i = 1; i < n; ++i)
    {
        if (s[0][i]!=0)
        {
            dp[0][i].first=dp[0][i-1].first+v2[0][i];
            dp[0][i].second=dp[0][i-1].second+v5[0][i];
            lst[0][i]='R';
        }
        else
        {
            dp[0][i].first=EXM;
            dp[0][i].second=EXM;
        }
        if (s[i][0]!=0)
        {
            dp[i][0].first=dp[i-1][0].first+v2[i][0];
            dp[i][0].second=dp[i-1][0].second+v5[i][0];
            lst[i][0]='D';
        }
        else
        {
            dp[i][0].first=EXM;
            dp[i][0].second=EXM;
        }
    }

    for (int i = 1; i < n; ++i)
    {
        for (int j = 1; j < n; ++j)
        {
            if (s[i][j]!=0){
                if (dp[i-1][j].first < dp[i][j-1].first){
                    dp[i][j].first=dp[i-1][j].first+v2[i][j];

                }
                else if (dp[i-1][j].first > dp[i][j-1].first){
                    dp[i][j].first=dp[i][j-1].first+v2[i][j];

                }
                else{
                    dp[i][j].first=dp[i][j-1].first+v2[i][j];
                }
                if (dp[i-1][j].second < dp[i][j-1].second){
                    dp[i][j].second=dp[i-1][j].second+v5[i][j];

                }
                else if (dp[i-1][j].second > dp[i][j-1].second){
                    dp[i][j].second=dp[i][j-1].second+v5[i][j];
                }
                else{
                    dp[i][j].second=dp[i][j-1].second+v5[i][j];
                }

            }
            else
            {
                dp[i][j].first=EXM;
                dp[i][j].second=EXM;
            }
        }
    }
//    for (int i = 0; i < n; ++i) {
//        for (int j = 0; j < n; ++j) {
//            cout<<min(dp[i][j].first,dp[i][j].second)<<' ';
//        }
//        cout<<endl;
//    }
    if (s[0][0]==0 || s[n-1][n-1]==0){
        cout<<1<<endl;
        for (int i = 0; i < n-1; ++i) {
            cout<<'D';
        }
        for (int i = 0; i < n-1; ++i) {
            cout<<'R';
        }
        return;
    }
    if (ned_check && min(dp[n-1][n-1].first,dp[n-1][n-1].second)>=1){

        cout<<1<<endl;
        for (int i = 0; i < ned.first; ++i) {
            cout<<'D';
        }
        for (int i = 0; i < n-1; ++i) {
            cout<<'R';
        }
        for (int i = ned.first; i < n-1; ++i) {
            cout<<'D';
        }
    }
    else{

        cout<<min(dp[n-1][n-1].first,dp[n-1][n-1].second)<<endl;
        if (dp[n-1][n-1].first<dp[n-1][n-1].second){
            dfs1(n-1,n-1);
        }
        else{
            dfs2(n-1,n-1);
        }
        while (!ans.empty()){
            cout<<ans.top();
            ans.pop();
        }
    }
}

signed main() {
//    cin>>t;
//    while (t--){
    solve();
//    }
    return 0;
}
```

<!--
 * ......................................&&.........................
 * ....................................&&&..........................
 * .................................&&&&............................
 * ...............................&&&&..............................
 * .............................&&&&&&..............................
 * ...........................&&&&&&....&&&..&&&&&&&&&&&&&&&........
 * ..................&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&..............
 * ................&...&&&&&&&&&&&&&&&&&&&&&&&&&&&&.................
 * .......................&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&.........
 * ...................&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&...............
 * ..................&&&   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&............
 * ...............&&&&&@  &&&&&&&&&&..&&&&&&&&&&&&&&&&&&&...........
 * ..............&&&&&&&&&&&&&&&.&&....&&&&&&&&&&&&&..&&&&&.........
 * ..........&&&&&&&&&&&&&&&&&&...&.....&&&&&&&&&&&&&...&&&&........
 * ........&&&&&&&&&&&&&&&&&&&.........&&&&&&&&&&&&&&&....&&&.......
 * .......&&&&&&&&.....................&&&&&&&&&&&&&&&&.....&&......
 * ........&&&&&.....................&&&&&&&&&&&&&&&&&&.............
 * ..........&...................&&&&&&&&&&&&&&&&&&&&&&&............
 * ................&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&............
 * ..................&&&&&&&&&&&&&&&&&&&&&&&&&&&&..&&&&&............
 * ..............&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&....&&&&&............
 * ...........&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&......&&&&............
 * .........&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&.........&&&&............
 * .......&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&...........&&&&............
 * ......&&&&&&&&&&&&&&&&&&&...&&&&&&...............&&&.............
 * .....&&&&&&&&&&&&&&&&............................&&..............
 * ....&&&&&&&&&&&&&&&.................&&...........................
 * ...&&&&&&&&&&&&&&&.....................&&&&......................
 * ...&&&&&&&&&&.&&&........................&&&&&...................
 * ..&&&&&&&&&&&..&&..........................&&&&&&&...............
 * ..&&&&&&&&&&&&...&............&&&.....&&&&...&&&&&&&.............
 * ..&&&&&&&&&&&&&.................&&&.....&&&&&&&&&&&&&&...........
 * ..&&&&&&&&&&&&&&&&..............&&&&&&&&&&&&&&&&&&&&&&&&.........
 * ..&&.&&&&&&&&&&&&&&&&&.........&&&&&&&&&&&&&&&&&&&&&&&&&&&.......
 * ...&&..&&&&&&&&&&&&.........&&&&&&&&&&&&&&&&...&&&&&&&&&&&&......
 * ....&..&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&...........&&&&&&&&.....
 * .......&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&..............&&&&&&&....
 * .......&&&&&.&&&&&&&&&&&&&&&&&&..&&&&&&&&...&..........&&&&&&....
 * ........&&&.....&&&&&&&&&&&&&.....&&&&&&&&&&...........&..&&&&...
 * .......&&&........&&&.&&&&&&&&&.....&&&&&.................&&&&...
 * .......&&&...............&&&&&&&.......&&&&&&&&............&&&...
 * ........&&...................&&&&&&.........................&&&..
 * .........&.....................&&&&........................&&....
 * ...............................&&&.......................&&......
 * ................................&&......................&&.......
 * .................................&&..............................
 * ..................................&..............................
 -->

 