[D. Sequence and Swaps](https://codeforces.com/contest/1455/problem/D)

## 神秘贪心


给出一个序列，要求通过操作排序，操作是将x与ai调换，而且条件是x< ai

那么我们就可以尝试测试样例1：

2，3，5，4

这个序列直观来看，5,4这个位置破坏了有序性，那么我们考虑这个操作，如果直接对5进行操作，

会构成序列 2 3 1 4，如果对4操作会产生 2 3 5 1

那么我们发现，对于测试1的最优解是操作2，3，5，变成1 2 3 4，


那么我们又会发现，对于一个正确，最优的操作来说，有 ai-1< x< ai 

所以，我们容易得到这样的贪心算法：

当x< ai 时将ai修改成x，我们写下代码，提交后会发现wa掉了。


为什么？

我们又发现，如果在x=1,而且序列为 2 3 4 5 的情况下，明明不需要修改就是有序的，但是我们的贪心算法又进行了4次操作，

我们再考虑一个情况，x=1, 序列为 2 7 3 6 7 8 9 ,我们发现，对于原来的贪心算法，会对2 7 操作得到1 2 3 6 7 8 9,这已经是有序的了，但是在遍历到8时，发生x=7 , ai=8的情况，但是，这种情况明明不应该修改，问题出在哪？

我们发现，对于后面的序列是有序的，因为我们的x< ai的性质，我们保证修改的ai不会比原来的大，

也就是说 如果ai 后有序，对于改完的ai也是有序的

那么我们就可以放心大胆的保留下来后面的有序序列，只要找到最后一个破坏序列升序性的值作为遍历的末尾就可以了！

``` python
def solve():
    n,x=map(int,input().split())
    s=list(map(int,input().split()))
    ans=0
    p=0
    for i in range(1,n):
        if s[i]<s[i-1]:
            p=i
    for i in range(p):
        if x<s[i]:
            ans+=1
            s[i],x=x,s[i]
    if s==sorted(s):
        print(ans)
    else:
        print(-1)
if __name__ == '__main__':
    for _ in range(int(input())):
        solve()

```