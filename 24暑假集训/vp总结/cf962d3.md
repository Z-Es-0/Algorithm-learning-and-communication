## 赛时开E，没开D

## 赛时ac: ABCE

反思： 逆天d题数论 ，e题超时红温了，失去冷静，后来给公式一化简就ac了;

## a

鸡兔同笼

## b

模拟

```python
import math
from queue import Queue
import bisect
import collections
import heapq


def solve():
    n,m=map(int,input().split())
    g=[]
    for i in range(n):
        s=list(input())
        g.append(s)
    # print(g)
    x=m
    for i in range(0,n,x):
        for j in range(0,n,x):
            print(g[i][j],end='')
        print()



def main():
    for i in range(int(input())):
        solve()


if __name__ == '__main__':
    main()


```

## c

神秘5s，可以暴力，可以26个字母前缀和查询集合是否重叠


```cpp
#include <bits/stdc++.h>

using namespace std;

void solve() {
    int n, q;
    cin >> n >> q;
    string a, b;
    cin >> a >> b;


    vector<vector<int>> prefixA(n + 1, vector<int>(26, 0));
    vector<vector<int>> prefixB(n + 1, vector<int>(26, 0));

    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < 26; ++j) {
            prefixA[i][j] = prefixA[i - 1][j];
            prefixB[i][j] = prefixB[i - 1][j];
        }
        prefixA[i][a[i - 1] - 'a']++;
        prefixB[i][b[i - 1] - 'a']++;
    }

  
    while (q--) {
        int l, r;
        cin >> l >> r;
        l--; 
        r--;

        vector<int> countA(26, 0), countB(26, 0);
        for (int i = 0; i < 26; ++i) {
            countA[i] = prefixA[r + 1][i] - prefixA[l][i];
            countB[i] = prefixB[r + 1][i] - prefixB[l][i];
        }

       
        int operations = 0;
        for (int i = 0; i < 26; ++i) {
            operations += abs(countA[i] - countB[i]);
        }
        cout << operations / 2 << endl; 
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int t;
    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```


## E
